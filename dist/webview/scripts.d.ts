export declare const whiteboardScripts = "\nconst vscode = acquireVsCodeApi();\n        const whiteboard = document.getElementById('whiteboard');\n        const canvasContainer = document.getElementById('canvas-container');\n        const contextMenu = document.getElementById('contextMenu');\n        const canvasContextMenu = document.getElementById('canvasContextMenu');\n        const fileModal = document.getElementById('fileModal');\n        const fileList = document.getElementById('fileList');\n        const colorGrid = document.getElementById('colorGrid');\n        const newCardModal = document.getElementById('newCardModal');\n        const dropIndicator = document.getElementById('dropIndicator');\n        const renameCardModal = document.getElementById('renameCardModal');\n        const moveCardModal = document.getElementById('moveCardModal');\n        const folderList = document.getElementById('folderList');\n        \n        let blocks = [];\n        let cards = [];\n        let selectedBlockId = null;\n        let contextBlockId = null;\n        let contextCardId = null;\n        let draggedBlock = null;\n        let draggedCard = null;\n        let resizingCard = null;\n        let dragOffset = { x: 0, y: 0 };\n        let zoomLevel = 1;\n        let panOffset = { x: 0, y: 0 };\n        let pendingCardPosition = { x: 0, y: 0 };\n\n        // Multi-selection state\n        let selectedBlocks = new Set();\n        let selectedCards = new Set();\n        let isSelecting = false;\n        let selectionStart = { x: 0, y: 0 };\n        let selectionBox = null;\n        let isMultiDragging = false;\n        let multiDragStart = { x: 0, y: 0 };\n        let initialPositions = new Map();\n\n        // ========== Save Optimization ==========\n        // Debounce: delay save until user stops making changes (500ms)\n        // Dirty Flag: only save if there are actual changes\n        let saveTimeoutId = null;\n        let isDirty = false;\n        let lastSavedState = null;\n        const SAVE_DEBOUNCE_MS = 500;\n        // ========================================\n\n        // ========== Rename/Move State ==========\n        let renameTargetCardId = null;\n        let renameTargetPath = null;\n        let moveTargetCardId = null;\n        let moveTargetPath = null;\n        let allWorkspaceFolders = [];\n        let filteredFolders = [];\n        let selectedFolderIndex = -1; // -1 means nothing selected (focus on search input)\n        let flatFolderList = []; // Flattened list of visible folders for keyboard navigation\n        // ========================================\n\n        // ========== Sidebar State ==========\n        const sidebar = document.getElementById('sidebar');\n        const toolbar = document.getElementById('toolbar');\n        const toggleSidebarBtn = document.getElementById('toggleSidebar');\n        const closeSidebarBtn = document.getElementById('closeSidebar');\n        const tabPinned = document.getElementById('tabPinned');\n        const tabCards = document.getElementById('tabCards');\n        const tabStash = document.getElementById('tabStash');\n        const panelPinned = document.getElementById('panelPinned');\n        const panelCards = document.getElementById('panelCards');\n        const panelStash = document.getElementById('panelStash');\n        const pinnedEmpty = document.getElementById('pinnedEmpty');\n        const pinnedFileViewer = document.getElementById('pinnedFileViewer');\n        const selectPinnedFileBtn = document.getElementById('selectPinnedFile');\n        const cardListElem = document.getElementById('cardList');\n        const cardListEmpty = document.getElementById('cardListEmpty');\n        const colorFilterSelect = document.getElementById('colorFilter');\n        const stashDropzone = document.getElementById('stashDropzone');\n        const stashListElem = document.getElementById('stashList');\n        const stashEmpty = document.getElementById('stashEmpty');\n        \n        let pinnedFiles = [];\n        let stashCards = [];\n        let currentPinnedFile = null;\n        let pinnedFileContent = '';\n        let sidebarOpen = false;\n        let currentColorFilter = '';\n        let cardBeingDraggedToStash = null;\n        // ===================================\n\n        // Colors palette - 8 deep colors for white text visibility\n        const colors = [\n            '#2563eb', // \u85CD Blue\n            '#dc2626', // \u7D05 Red\n            '#ea580c', // \u6A58 Orange\n            '#16a34a', // \u7DA0 Green\n            '#4b5563', // \u6DF1\u7070 Dark Gray\n            '#7c3aed', // \u7D2B Purple\n            '#db2777', // \u7C89 Pink\n            '#92400e'  // \u5496 Brown\n        ];\n\n        // Initialize color grid\n        colors.forEach(color => {\n            const colorDiv = document.createElement('div');\n            colorDiv.className = 'color-option';\n            colorDiv.style.background = color;\n            colorDiv.dataset.color = color;\n            colorDiv.addEventListener('click', () => changeBlockColor(color));\n            colorGrid.appendChild(colorDiv);\n        });\n\n        function generateId() {\n            return 'block_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n        }\n\n        function createBlockElement(block) {\n            const div = document.createElement('div');\n            div.className = 'block' + (block.linkedFile ? ' linked' : '');\n            div.id = block.id;\n            div.style.left = block.x + 'px';\n            div.style.top = block.y + 'px';\n            div.style.background = block.color;\n\n            // Display Content (Div)\n            const contentDiv = document.createElement('div');\n            contentDiv.className = 'block-content';\n            contentDiv.textContent = block.text;\n            div.appendChild(contentDiv);\n\n            // Editable Input (Textarea)\n            const textarea = document.createElement('textarea');\n            textarea.className = 'block-input';\n            textarea.value = block.text;\n            textarea.placeholder = 'Type here...';\n            div.appendChild(textarea);\n            \n            // Events for Input\n            textarea.addEventListener('input', (e) => {\n                block.text = e.target.value;\n                contentDiv.textContent = block.text; // sync content\n                saveState();\n            });\n\n            textarea.addEventListener('blur', () => {\n                div.classList.remove('editing');\n            });\n\n            textarea.addEventListener('mousedown', (e) => e.stopPropagation()); // Prevent drag when editing\n\n            // Double click to edit\n            div.addEventListener('dblclick', (e) => {\n                e.stopPropagation(); // Prevent canvas double click\n                e.preventDefault();\n                div.classList.add('editing');\n                setTimeout(() => textarea.focus(), 0);\n            });\n\n            // Click on text content to open linked file (only text area, not surrounding space)\n            // Cmd+click (Mac) or Ctrl+click (Win): open file in main view\n            // Option+click (Mac) or Alt+click (Win): open file in split view\n            // Cmd+Option+click: also open in split view\n            contentDiv.addEventListener('click', (e) => {\n                if (div.classList.contains('editing')) return;\n                \n                // If it was a drag release, don't open file\n                if (draggedBlock) return;\n\n                if (block.linkedFile) {\n                    // Require Cmd/Ctrl OR Option/Alt to open file - prevents accidental opens\n                    if (!e.metaKey && !e.ctrlKey && !e.altKey) return;\n                    \n                    e.preventDefault();\n                    e.stopPropagation();\n                    const splitView = e.altKey;\n                    vscode.postMessage({ command: 'openFile', filePath: block.linkedFile, splitView: splitView });\n                }\n            });\n\n            // Dragging (MouseDown on the whole block)\n            div.addEventListener('mousedown', (e) => {\n                if (div.classList.contains('editing')) return; // Don't drag if editing\n                if (e.button !== 0) return; // Only Left Click\n                \n                // Check if this block is part of a multi-selection\n                if (isBlockSelected(block.id)) {\n                    // Start multi-drag if clicking on an already selected block\n                    e.stopPropagation();\n                    startMultiDrag(e);\n                } else if (e.shiftKey) {\n                    // Shift+click to add to selection\n                    e.stopPropagation();\n                    toggleBlockSelection(block.id, true);\n                } else {\n                    // Normal click - select this item and start single drag\n                    clearSelection();\n                    selectedBlocks.add(block.id);\n                    div.classList.add('selected');\n                    startDrag(e, div, block);\n                }\n            });\n\n            // Context menu\n            div.addEventListener('contextmenu', (e) => {\n                e.preventDefault();\n                showContextMenu(e, block.id);\n            });\n\n            return div;\n        }\n\n        function startDrag(e, element, block) {\n            draggedBlock = { element, block };\n            element.classList.add('dragging');\n            \n            const rect = element.getBoundingClientRect();\n            dragOffset = {\n                x: (e.clientX - rect.left) / zoomLevel,\n                y: (e.clientY - rect.top) / zoomLevel\n            };\n\n            document.addEventListener('mousemove', onDrag);\n            document.addEventListener('mouseup', stopDrag);\n        }\n\n        function onDrag(e) {\n            if (!draggedBlock) return;\n            e.preventDefault(); // Prevent text selection\n\n            const pos = screenToWhiteboard(e.clientX, e.clientY);\n            const x = pos.x - dragOffset.x;\n            const y = pos.y - dragOffset.y;\n\n            draggedBlock.element.style.left = x + 'px';\n            draggedBlock.element.style.top = y + 'px';\n\n            draggedBlock.block.x = x;\n            draggedBlock.block.y = y;\n        }\n\n        function stopDrag() {\n            if (draggedBlock) {\n                draggedBlock.element.classList.remove('dragging');\n                draggedBlock = null;\n                saveState();\n            }\n            document.removeEventListener('mousemove', onDrag);\n            document.removeEventListener('mouseup', stopDrag);\n        }\n\n        function addBlock(x, y) {\n            // Default center if no coords - use whiteboard center\n            const centerPos = screenToWhiteboard(canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);\n            const startX = x !== undefined ? x : centerPos.x - 100;\n            const startY = y !== undefined ? y : centerPos.y - 50;\n\n            const block = {\n                id: generateId(),\n                x: startX,\n                y: startY,\n                color: colors[Math.floor(Math.random() * colors.length)],\n                text: 'New Block',\n                linkedFile: null\n            };\n\n            blocks.push(block);\n            const element = createBlockElement(block);\n            whiteboard.appendChild(element);\n            saveState();\n            \n            // Auto enter edit mode\n            setTimeout(() => {\n                const event = new MouseEvent('dblclick', { bubbles: true });\n                element.dispatchEvent(event);\n            }, 50);\n        }\n\n        function showContextMenu(e, blockId) {\n            contextBlockId = blockId;\n            const block = blocks.find(b => b.id === blockId);\n            \n            const unlinkMenu = document.getElementById('unlinkFileMenu');\n            unlinkMenu.style.display = block.linkedFile ? 'flex' : 'none';\n\n            // Menu positioning\n            let x = e.pageX;\n            let y = e.pageY;\n            \n            // Bound checking\n            const menuWidth = 220;\n            const menuHeight = 200;\n            if (x + menuWidth > window.innerWidth) x -= menuWidth;\n            if (y + menuHeight > window.innerHeight) y -= menuHeight;\n\n            contextMenu.style.left = x + 'px';\n            contextMenu.style.top = y + 'px';\n            contextMenu.classList.add('active');\n        }\n\n        function hideContextMenu() {\n            contextMenu.classList.remove('active');\n            contextBlockId = null;\n        }\n\n        function changeBlockColor(color) {\n            if (contextCardId) {\n                // Change card color\n                const card = cards.find(c => c.id === contextCardId);\n                if (card) {\n                    card.color = color;\n                    const element = document.getElementById(contextCardId);\n                    if (element) {\n                        // Apply to entire card (lighter)\n                        element.style.background = colorWithAlpha(color, 0.15);\n                        element.style.borderColor = colorWithAlpha(color, 0.4);\n                        \n                        // Apply to header (slightly more opaque)\n                        const header = element.querySelector('.card-header');\n                        if (header) {\n                            header.style.background = colorWithAlpha(color, 0.35);\n                        }\n                    }\n                    saveState();\n                }\n                hideContextMenu();\n                return;\n            }\n            \n            if (!contextBlockId) return;\n            const block = blocks.find(b => b.id === contextBlockId);\n            if (block) {\n                block.color = color;\n                const element = document.getElementById(contextBlockId);\n                element.style.background = color;\n                saveState();\n            }\n            hideContextMenu();\n        }\n\n        function deleteBlock() {\n            if (!contextBlockId) return;\n            blocks = blocks.filter(b => b.id !== contextBlockId);\n            const element = document.getElementById(contextBlockId);\n            if (element) {\n                element.style.transform = 'scale(0)';\n                element.style.opacity = '0';\n                setTimeout(() => element.remove(), 200);\n            }\n            forceSave(); // Use forceSave for delete operations\n            hideContextMenu();\n        }\n\n        function unlinkFile() {\n            if (!contextBlockId) return;\n            const block = blocks.find(b => b.id === contextBlockId);\n            if (block) {\n                block.linkedFile = null;\n                const element = document.getElementById(contextBlockId);\n                element.classList.remove('linked');\n                saveState();\n            }\n            hideContextMenu();\n        }\n\n        // File selector state\n        let allWorkspaceFiles = [];\n        let selectedFileIndex = -1;\n        let filteredFiles = [];\n        let fileSelectorMode = 'block'; // 'block' for linking to block, 'card' for creating new card\n        const fileSearchInput = document.getElementById('fileSearchInput');\n        const newFileItem = document.getElementById('newFileItem');\n\n        function openFileSelector(blockId, mode = 'block') {\n            fileSelectorMode = mode;\n            selectedBlockId = blockId || contextBlockId;\n            selectedFileIndex = -1;\n            fileSearchInput.value = '';\n            \n            // Update modal title based on mode\n            const modalTitle = fileModal.querySelector('h3');\n            if (modalTitle) {\n                if (mode === 'card') {\n                    modalTitle.innerHTML = '<svg class=\"icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"16\" y1=\"13\" x2=\"8\" y2=\"13\"></line><line x1=\"16\" y1=\"17\" x2=\"8\" y2=\"17\"></line><line x1=\"10\" y1=\"9\" x2=\"8\" y2=\"9\"></line></svg> Select or Create Card';\n                } else if (mode === 'pinned') {\n                    modalTitle.innerHTML = '<svg class=\"icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline></svg> Select Pinned File';\n                } else {\n                    modalTitle.innerHTML = '<svg class=\"icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2\"></path></svg> Select Markdown File';\n                }\n            }\n            \n            vscode.postMessage({ command: 'getWorkspaceFiles' });\n            fileModal.classList.add('active');\n            setTimeout(() => fileSearchInput.focus(), 100);\n            hideContextMenu();\n            hideCanvasContextMenu();\n        }\n\n        function closeFileSelector() {\n            fileModal.classList.remove('active');\n            selectedBlockId = null;\n            selectedFileIndex = -1;\n        }\n\n        function renderFileList(files) {\n            filteredFiles = files;\n            if (files.length === 0) {\n                fileList.innerHTML = '<div class=\"no-results\">\u627E\u4E0D\u5230\u7B26\u5408\u7684\u6A94\u6848</div>';\n            } else {\n                fileList.innerHTML = files.map((f, i) => \n                    `<div class=\"file-item${i === selectedFileIndex ? ' selected' : ''}\" data-file=\"${f}\" data-index=\"${i}\">${f}</div>`\n                ).join('');\n                fileList.querySelectorAll('.file-item').forEach(item => {\n                    item.addEventListener('click', () => selectFile(item.dataset.file));\n                });\n            }\n            \n            // Update new file button text based on search query\n            const query = fileSearchInput.value.trim();\n            const newFileText = newFileItem.querySelector('span:last-child');\n            if (newFileText) {\n                if (query) {\n                    newFileText.textContent = `Create ${query}...`;\n                } else {\n                    newFileText.textContent = '\u5EFA\u7ACB\u65B0\u6A94\u6848...';\n                }\n            }\n            \n            updateNewFileItemSelection();\n        }\n\n        function updateNewFileItemSelection() {\n            // New File item is selected when selectedFileIndex equals filteredFiles.length\n            if (selectedFileIndex === filteredFiles.length) {\n                newFileItem.classList.add('selected');\n            } else {\n                newFileItem.classList.remove('selected');\n            }\n        }\n\n        function updateSelectedItem() {\n            fileList.querySelectorAll('.file-item').forEach((item, i) => {\n                if (i === selectedFileIndex) {\n                    item.classList.add('selected');\n                    item.scrollIntoView({ block: 'nearest' });\n                } else {\n                    item.classList.remove('selected');\n                }\n            });\n            updateNewFileItemSelection();\n        }\n\n        function filterFiles(query) {\n            const q = query.toLowerCase();\n            const filtered = allWorkspaceFiles.filter(f => f.toLowerCase().includes(q));\n            \n            // If no matching files and there's a query, auto-select the \"Create\" option\n            if (filtered.length === 0 && query.trim()) {\n                selectedFileIndex = 0; // Will be set to newFileItem (filteredFiles.length = 0)\n            } else {\n                selectedFileIndex = -1;\n            }\n            \n            renderFileList(filtered);\n        }\n\n        // File search input events\n        fileSearchInput.addEventListener('input', (e) => {\n            filterFiles(e.target.value);\n        });\n\n        fileSearchInput.addEventListener('keydown', (e) => {\n            const totalItems = filteredFiles.length + 1; // +1 for New File item\n            \n            if (e.key === 'ArrowDown') {\n                e.preventDefault();\n                if (selectedFileIndex >= totalItems - 1) {\n                    // At the end (Create button), wrap to input (-1)\n                    selectedFileIndex = -1;\n                } else {\n                    selectedFileIndex = selectedFileIndex + 1;\n                }\n                updateSelectedItem();\n            } else if (e.key === 'ArrowUp') {\n                e.preventDefault();\n                if (selectedFileIndex <= -1) {\n                    // At input, jump to Create button (last item)\n                    selectedFileIndex = totalItems - 1;\n                } else {\n                    selectedFileIndex = selectedFileIndex - 1;\n                }\n                updateSelectedItem();\n            } else if (e.key === 'Enter') {\n                e.preventDefault();\n                if (selectedFileIndex >= 0 && selectedFileIndex < filteredFiles.length) {\n                    selectFile(filteredFiles[selectedFileIndex]);\n                } else if (selectedFileIndex === filteredFiles.length) {\n                    // New File selected\n                    handleNewFileClick();\n                }\n            } else if (e.key === 'Escape') {\n                closeFileSelector();\n            }\n        });\n\n        // New File item click\n        newFileItem.addEventListener('click', handleNewFileClick);\n\n        function handleNewFileClick() {\n            const query = fileSearchInput.value.trim();\n            \n            if (fileSelectorMode === 'card') {\n                // Card mode: create new card\n                if (query) {\n                    // Directly create file with the search query as filename\n                    vscode.postMessage({ \n                        command: 'createNewCard', \n                        fileName: query,\n                        x: pendingCardPosition.x - 150,\n                        y: pendingCardPosition.y - 100\n                    });\n                    closeFileSelector();\n                } else {\n                    // No query - open modal for filename input\n                    closeFileSelector();\n                    newCardModal.classList.add('active');\n                    document.getElementById('newCardFileName').value = '';\n                    document.getElementById('newCardFileName').focus();\n                }\n            } else {\n                // Block mode: link file to block\n                if (query && selectedBlockId) {\n                    // Directly create file with the search query as filename\n                    vscode.postMessage({ \n                        command: 'createNewCard', \n                        fileName: query,\n                        x: 0,\n                        y: 0,\n                        forBlockId: selectedBlockId\n                    });\n                    closeFileSelector();\n                } else if (selectedBlockId) {\n                    // No query - open modal for filename input\n                    closeFileSelector();\n                    newFileForBlockMode = true;\n                    newCardModal.classList.add('active');\n                    document.getElementById('newCardFileName').value = '';\n                    document.getElementById('newCardFileName').focus();\n                }\n            }\n        }\n\n        let newFileForBlockMode = false;\n\n        function selectFile(filePath) {\n            if (fileSelectorMode === 'card') {\n                // Add existing file as a new card\n                addCard(filePath, pendingCardPosition.x - 150, pendingCardPosition.y - 100);\n                closeFileSelector();\n            } else if (fileSelectorMode === 'pinned') {\n                // Add file to pinned files list\n                if (!pinnedFiles.includes(filePath)) {\n                    pinnedFiles.push(filePath);\n                }\n                currentPinnedFile = filePath;\n                closeFileSelector();\n                renderPinnedFiles();\n                saveState();\n            } else {\n                // Link file to block\n                if (!selectedBlockId) return;\n\n                const block = blocks.find(b => b.id === selectedBlockId);\n                if (block) {\n                    block.linkedFile = filePath;\n                    const element = document.getElementById(selectedBlockId);\n                    element.classList.add('linked');\n                    saveState();\n                }\n\n                closeFileSelector();\n            }\n        }\n\n        function updateWhiteboardTransform() {\n            whiteboard.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoomLevel})`;\n        }\n\n        // Convert screen coordinates to whiteboard coordinates\n        function screenToWhiteboard(screenX, screenY) {\n            return {\n                x: (screenX - panOffset.x) / zoomLevel,\n                y: (screenY - panOffset.y) / zoomLevel\n            };\n        }\n\n        function setZoom(level, mouseX = null, mouseY = null, smooth = false) {\n            const oldZoom = zoomLevel;\n            const newZoom = Math.max(0.1, Math.min(5, level)); // Wider zoom range\n            \n            // If no position provided, default to viewport center\n            if (mouseX === null || mouseY === null) {\n                mouseX = canvasContainer.clientWidth / 2;\n                mouseY = canvasContainer.clientHeight / 2;\n            }\n            \n            // Calculate the point on whiteboard that mouse is pointing at\n            const pointX = (mouseX - panOffset.x) / oldZoom;\n            const pointY = (mouseY - panOffset.y) / oldZoom;\n            \n            // Adjust pan offset so that same point stays under mouse after zoom\n            panOffset.x = mouseX - pointX * newZoom;\n            panOffset.y = mouseY - pointY * newZoom;\n            \n            zoomLevel = newZoom;\n            \n            // Apply smooth transition for button clicks\n            if (smooth) {\n                whiteboard.style.transition = 'transform 0.2s ease-out';\n                // Remove transition after animation completes\n                setTimeout(() => {\n                    whiteboard.style.transition = '';\n                }, 200);\n            }\n            \n            updateWhiteboardTransform();\n            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';\n        }\n\n        // Multi-selection functions\n        function clearSelection() {\n            selectedBlocks.forEach(id => {\n                const el = document.getElementById(id);\n                if (el) el.classList.remove('selected');\n            });\n            selectedCards.forEach(id => {\n                const el = document.getElementById(id);\n                if (el) el.classList.remove('selected');\n            });\n            selectedBlocks.clear();\n            selectedCards.clear();\n        }\n\n        /**\n         * Exit all editing modes for blocks and cards\n         * Called when clicking on empty canvas area\n         */\n        function exitAllEditingModes() {\n            // Exit block editing mode\n            const editingBlocks = document.querySelectorAll('.block.editing');\n            editingBlocks.forEach(block => {\n                block.classList.remove('editing');\n                // Sync text content from input to display\n                const textarea = block.querySelector('.block-input');\n                const contentDiv = block.querySelector('.block-content');\n                if (textarea && contentDiv) {\n                    contentDiv.textContent = textarea.value;\n                }\n            });\n\n            // Exit card editing mode (blur active textarea)\n            const editingCards = document.querySelectorAll('.card.editing');\n            editingCards.forEach(card => {\n                card.classList.remove('editing');\n            });\n\n            // Blur any focused textarea/input\n            if (document.activeElement && \n                (document.activeElement.tagName === 'TEXTAREA' || \n                 document.activeElement.tagName === 'INPUT')) {\n                document.activeElement.blur();\n            }\n        }\n\n        function toggleBlockSelection(blockId, additive = false) {\n            if (!additive) {\n                clearSelection();\n            }\n            \n            if (selectedBlocks.has(blockId)) {\n                selectedBlocks.delete(blockId);\n                document.getElementById(blockId)?.classList.remove('selected');\n            } else {\n                selectedBlocks.add(blockId);\n                document.getElementById(blockId)?.classList.add('selected');\n            }\n        }\n\n        function toggleCardSelection(cardId, additive = false) {\n            if (!additive) {\n                clearSelection();\n            }\n            \n            if (selectedCards.has(cardId)) {\n                selectedCards.delete(cardId);\n                document.getElementById(cardId)?.classList.remove('selected');\n            } else {\n                selectedCards.add(cardId);\n                document.getElementById(cardId)?.classList.add('selected');\n            }\n        }\n\n        function startSelectionBox(e) {\n            const pos = screenToWhiteboard(e.clientX, e.clientY);\n            selectionStart = { x: pos.x, y: pos.y };\n            isSelecting = true;\n            \n            // Create selection box element\n            selectionBox = document.createElement('div');\n            selectionBox.className = 'selection-box';\n            selectionBox.style.left = pos.x + 'px';\n            selectionBox.style.top = pos.y + 'px';\n            selectionBox.style.width = '0px';\n            selectionBox.style.height = '0px';\n            whiteboard.appendChild(selectionBox);\n        }\n\n        function updateSelectionBox(e) {\n            if (!isSelecting || !selectionBox) return;\n            \n            const pos = screenToWhiteboard(e.clientX, e.clientY);\n            \n            const left = Math.min(selectionStart.x, pos.x);\n            const top = Math.min(selectionStart.y, pos.y);\n            const width = Math.abs(pos.x - selectionStart.x);\n            const height = Math.abs(pos.y - selectionStart.y);\n            \n            selectionBox.style.left = left + 'px';\n            selectionBox.style.top = top + 'px';\n            selectionBox.style.width = width + 'px';\n            selectionBox.style.height = height + 'px';\n        }\n\n        function endSelectionBox(e, additive = false) {\n            if (!isSelecting || !selectionBox) return;\n            \n            const pos = screenToWhiteboard(e.clientX, e.clientY);\n            \n            const selRect = {\n                left: Math.min(selectionStart.x, pos.x),\n                top: Math.min(selectionStart.y, pos.y),\n                right: Math.max(selectionStart.x, pos.x),\n                bottom: Math.max(selectionStart.y, pos.y)\n            };\n            \n            // Only clear if not additive (Shift not held)\n            if (!additive) {\n                clearSelection();\n            }\n            \n            // Check blocks for intersection\n            blocks.forEach(block => {\n                const blockRect = {\n                    left: block.x,\n                    top: block.y,\n                    right: block.x + 200, // block width\n                    bottom: block.y + 100 // block height\n                };\n                \n                if (rectsIntersect(selRect, blockRect)) {\n                    selectedBlocks.add(block.id);\n                    document.getElementById(block.id)?.classList.add('selected');\n                }\n            });\n            \n            // Check cards for intersection\n            cards.forEach(card => {\n                const cardRect = {\n                    left: card.x,\n                    top: card.y,\n                    right: card.x + (card.width || 300),\n                    bottom: card.y + (card.height || 200)\n                };\n                \n                if (rectsIntersect(selRect, cardRect)) {\n                    selectedCards.add(card.id);\n                    document.getElementById(card.id)?.classList.add('selected');\n                }\n            });\n            \n            // Remove selection box\n            selectionBox.remove();\n            selectionBox = null;\n            isSelecting = false;\n        }\n\n        function rectsIntersect(a, b) {\n            return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);\n        }\n\n        function startMultiDrag(e) {\n            if (selectedBlocks.size === 0 && selectedCards.size === 0) return;\n            \n            isMultiDragging = true;\n            multiDragStart = screenToWhiteboard(e.clientX, e.clientY);\n            \n            // Store initial positions\n            initialPositions.clear();\n            selectedBlocks.forEach(id => {\n                const block = blocks.find(b => b.id === id);\n                if (block) {\n                    initialPositions.set(id, { x: block.x, y: block.y });\n                }\n            });\n            selectedCards.forEach(id => {\n                const card = cards.find(c => c.id === id);\n                if (card) {\n                    initialPositions.set(id, { x: card.x, y: card.y });\n                }\n            });\n            \n            document.addEventListener('mousemove', onMultiDrag);\n            document.addEventListener('mouseup', stopMultiDrag);\n        }\n\n        function onMultiDrag(e) {\n            if (!isMultiDragging) return;\n            e.preventDefault();\n            \n            const currentPos = screenToWhiteboard(e.clientX, e.clientY);\n            const deltaX = currentPos.x - multiDragStart.x;\n            const deltaY = currentPos.y - multiDragStart.y;\n            \n            // Move all selected blocks\n            selectedBlocks.forEach(id => {\n                const block = blocks.find(b => b.id === id);\n                const initial = initialPositions.get(id);\n                if (block && initial) {\n                    block.x = initial.x + deltaX;\n                    block.y = initial.y + deltaY;\n                    const el = document.getElementById(id);\n                    if (el) {\n                        el.style.left = block.x + 'px';\n                        el.style.top = block.y + 'px';\n                    }\n                }\n            });\n            \n            // Move all selected cards\n            selectedCards.forEach(id => {\n                const card = cards.find(c => c.id === id);\n                const initial = initialPositions.get(id);\n                if (card && initial) {\n                    card.x = initial.x + deltaX;\n                    card.y = initial.y + deltaY;\n                    const el = document.getElementById(id);\n                    if (el) {\n                        el.style.left = card.x + 'px';\n                        el.style.top = card.y + 'px';\n                    }\n                }\n            });\n        }\n\n        function stopMultiDrag() {\n            if (isMultiDragging) {\n                isMultiDragging = false;\n                initialPositions.clear();\n                saveState();\n            }\n            document.removeEventListener('mousemove', onMultiDrag);\n            document.removeEventListener('mouseup', stopMultiDrag);\n        }\n\n        function isBlockSelected(blockId) {\n            return selectedBlocks.has(blockId);\n        }\n\n        function isCardSelected(cardId) {\n            return selectedCards.has(cardId);\n        }\n\n        /**\n         * Mark state as dirty and schedule a save\n         * Uses debounce to avoid saving too frequently\n         */\n        function saveState() {\n            isDirty = true;\n            scheduleSave();\n        }\n\n        /**\n         * Schedule a save with debounce\n         * Cancels any pending save and starts a new timer\n         */\n        function scheduleSave() {\n            if (saveTimeoutId) {\n                clearTimeout(saveTimeoutId);\n            }\n            saveTimeoutId = setTimeout(() => {\n                performSave();\n            }, SAVE_DEBOUNCE_MS);\n        }\n\n        /**\n         * Actually perform the save if there are changes\n         * Uses dirty flag to skip unnecessary saves\n         */\n        function performSave() {\n            saveTimeoutId = null;\n            \n            if (!isDirty) {\n                return; // No changes, skip save\n            }\n\n            const currentState = JSON.stringify({ blocks, cards, pinnedFiles, stashCards });\n            \n            // Check if state actually changed (deep comparison)\n            if (lastSavedState === currentState) {\n                isDirty = false;\n                return; // No actual changes, skip save\n            }\n\n            // Actually save\n            vscode.postMessage({ command: 'saveState', state: { blocks, cards, pinnedFiles, stashCards } });\n            lastSavedState = currentState;\n            isDirty = false;\n        }\n\n        /**\n         * Force an immediate save (used for critical operations)\n         * Bypasses debounce but still respects dirty flag\n         */\n        function forceSave() {\n            if (saveTimeoutId) {\n                clearTimeout(saveTimeoutId);\n                saveTimeoutId = null;\n            }\n            performSave();\n        }\n\n        function loadState(state) {\n            blocks = state.blocks || [];\n            cards = state.cards || [];\n            pinnedFiles = state.pinnedFiles || [];\n            stashCards = state.stashCards || [];\n            \n            whiteboard.innerHTML = '';\n            blocks.forEach(block => {\n                const element = createBlockElement(block);\n                whiteboard.appendChild(element);\n            });\n            cards.forEach(card => {\n                const element = createCardElement(card);\n                whiteboard.appendChild(element);\n                // Load card content\n                vscode.postMessage({ command: 'readCardContent', cardId: card.id, filePath: card.filePath });\n            });\n            \n            // Initialize sidebar data\n            initSidebar();\n        }\n\n        // Helper function to convert hex color to rgba with alpha\n        function colorWithAlpha(hexColor, alpha) {\n            // Handle hex colors\n            if (hexColor && hexColor.startsWith('#')) {\n                const hex = hexColor.slice(1);\n                const r = parseInt(hex.substr(0, 2), 16);\n                const g = parseInt(hex.substr(2, 2), 16);\n                const b = parseInt(hex.substr(4, 2), 16);\n                return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';\n            }\n            return hexColor;\n        }\n\n        // Helper function to extract filename from path\n        function getFileName(filePath) {\n            if (!filePath) return 'Unknown';\n            // Handle both forward and backward slashes\n            const parts = filePath.replace(/\\\\/g, '/').split('/');\n            return parts[parts.length - 1];\n        }\n\n        function createCardElement(card) {\n            const div = document.createElement('div');\n            div.className = 'card' + (card.collapsed ? ' collapsed' : '');\n            div.id = card.id;\n            div.style.left = card.x + 'px';\n            div.style.top = card.y + 'px';\n            div.style.width = (card.width || 300) + 'px';\n            if (!card.collapsed) {\n                div.style.height = (card.height || 200) + 'px';\n            }\n            \n            // Apply card color to entire card background (lighter version)\n            if (card.color) {\n                div.style.background = colorWithAlpha(card.color, 0.15);\n                div.style.borderColor = colorWithAlpha(card.color, 0.4);\n            }\n\n            // Header - only show filename, not full path\n            const header = document.createElement('div');\n            header.className = 'card-header';\n            \n            // Apply card color to header (slightly more opaque)\n            if (card.color) {\n                header.style.background = colorWithAlpha(card.color, 0.35);\n            }\n            \n            // Collapse toggle triangle\n            const collapseToggle = document.createElement('div');\n            collapseToggle.className = 'card-collapse-toggle';\n            collapseToggle.title = card.collapsed ? 'Expand' : 'Collapse';\n            header.appendChild(collapseToggle);\n            \n            // File icon - clickable to open file (requires Cmd/Ctrl)\n            const fileIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            fileIcon.setAttribute('class', 'icon-sm');\n            fileIcon.setAttribute('viewBox', '0 0 24 24');\n            fileIcon.setAttribute('fill', 'none');\n            fileIcon.setAttribute('stroke', 'currentColor');\n            fileIcon.setAttribute('stroke-width', '2');\n            fileIcon.setAttribute('stroke-linecap', 'round');\n            fileIcon.setAttribute('stroke-linejoin', 'round');\n            fileIcon.innerHTML = '<path d=\"M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"16\" y1=\"13\" x2=\"8\" y2=\"13\"></line><line x1=\"16\" y1=\"17\" x2=\"8\" y2=\"17\"></line><line x1=\"10\" y1=\"9\" x2=\"8\" y2=\"9\"></line>';\n            fileIcon.style.cursor = 'pointer';\n            fileIcon.addEventListener('click', (e) => {\n                // Require Cmd/Ctrl OR Option/Alt to open file - prevents accidental opens\n                if (!e.metaKey && !e.ctrlKey && !e.altKey) return;\n                \n                e.preventDefault();\n                e.stopPropagation();\n                const splitView = e.altKey;\n                vscode.postMessage({ command: 'openFile', filePath: card.filePath, splitView: splitView });\n            });\n            header.appendChild(fileIcon);\n            \n            // Filename - clickable to open file (requires Cmd/Ctrl)\n            const displayName = getFileName(card.filePath);\n            const filenameSpan = document.createElement('span');\n            filenameSpan.className = 'filename';\n            filenameSpan.textContent = displayName;\n            filenameSpan.style.cursor = 'pointer';\n            filenameSpan.title = 'Cmd+click or Option+click to open file';\n            \n            // Click on filename to open file (requires Cmd/Ctrl OR Option/Alt)\n            filenameSpan.addEventListener('click', (e) => {\n                // Require Cmd/Ctrl OR Option/Alt to open file - prevents accidental opens\n                if (!e.metaKey && !e.ctrlKey && !e.altKey) return;\n                \n                e.preventDefault();\n                e.stopPropagation();\n                const splitView = e.altKey;\n                vscode.postMessage({ command: 'openFile', filePath: card.filePath, splitView: splitView });\n            });\n            \n            header.appendChild(filenameSpan);\n            \n            div.appendChild(header);\n\n            // Content\n            const content = document.createElement('div');\n            content.className = 'card-content';\n            \n            // Textarea for editing\n            const textarea = document.createElement('textarea');\n            textarea.className = 'card-textarea';\n            textarea.placeholder = 'Loading...';\n            textarea.dataset.cardId = card.id;\n            content.appendChild(textarea);\n            \n            // Disconnected message container (hidden by default)\n            const disconnectedContainer = document.createElement('div');\n            disconnectedContainer.className = 'disconnected-container';\n            disconnectedContainer.style.display = 'none';\n            \n            const disconnectedMsg = document.createElement('div');\n            disconnectedMsg.className = 'disconnected-message';\n            disconnectedMsg.textContent = '\u6B64\u6587\u4EF6\u5DF2\u65B7\u958B\u9023\u7D50';\n            disconnectedContainer.appendChild(disconnectedMsg);\n            \n            const refreshBtn = document.createElement('button');\n            refreshBtn.className = 'refresh-btn';\n            refreshBtn.innerHTML = '<svg class=\"icon-sm\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><polyline points=\"23 4 23 10 17 10\"></polyline><polyline points=\"1 20 1 14 7 14\"></polyline><path d=\"M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15\"></path></svg> \u91CD\u65B0\u9023\u7D50';\n            refreshBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                // Try to reload the file content\n                vscode.postMessage({ command: 'readCardContent', cardId: card.id, filePath: card.filePath });\n            });\n            disconnectedContainer.appendChild(refreshBtn);\n            \n            content.appendChild(disconnectedContainer);\n            div.appendChild(content);\n\n            // Resize handle\n            const resizeHandle = document.createElement('div');\n            resizeHandle.className = 'card-resize-handle';\n            div.appendChild(resizeHandle);\n\n            // Collapse toggle click handler\n            collapseToggle.addEventListener('click', (e) => {\n                e.stopPropagation();\n                card.collapsed = !card.collapsed;\n                div.classList.toggle('collapsed');\n                collapseToggle.title = card.collapsed ? 'Expand' : 'Collapse';\n                \n                if (!card.collapsed) {\n                    // Restore height when expanding\n                    div.style.height = (card.height || 200) + 'px';\n                } else {\n                    // Remove explicit height when collapsing\n                    div.style.height = '';\n                }\n                saveState();\n            });\n\n            // Drag by header (but not by clicking on toggle)\n            header.addEventListener('mousedown', (e) => {\n                if (e.target === collapseToggle || collapseToggle.contains(e.target)) return;\n                if (e.button !== 0) return;\n                \n                // Check if this card is part of a multi-selection\n                if (isCardSelected(card.id)) {\n                    // Start multi-drag if clicking on an already selected card\n                    e.stopPropagation();\n                    startMultiDrag(e);\n                } else if (e.shiftKey) {\n                    // Shift+click to add to selection\n                    e.stopPropagation();\n                    toggleCardSelection(card.id, true);\n                } else {\n                    // Normal click - select this item and start single drag\n                    clearSelection();\n                    selectedCards.add(card.id);\n                    div.classList.add('selected');\n                    startCardDrag(e, div, card);\n                }\n            });\n\n            // Resize\n            resizeHandle.addEventListener('mousedown', (e) => {\n                e.stopPropagation();\n                startCardResize(e, div, card);\n            });\n\n            // Save content on change (debounced)\n            let saveTimeout;\n            textarea.addEventListener('input', () => {\n                clearTimeout(saveTimeout);\n                saveTimeout = setTimeout(() => {\n                    vscode.postMessage({ \n                        command: 'saveCardContent', \n                        filePath: card.filePath, \n                        content: textarea.value \n                    });\n                    // Update lastModified timestamp\n                    updateCardLastModified(card.id);\n                    saveState();\n                }, 500);\n            });\n\n            // Add editing class when focused for visual feedback\n            textarea.addEventListener('focus', () => {\n                div.classList.add('editing');\n            });\n\n            textarea.addEventListener('blur', () => {\n                div.classList.remove('editing');\n            });\n\n            // Context menu\n            div.addEventListener('contextmenu', (e) => {\n                e.preventDefault();\n                showCardContextMenu(e, card.id);\n            });\n\n            // Enable HTML5 drag & drop to stash\n            enableCardDragToStash(div, card);\n\n            return div;\n\n        }\n\n        function startCardDrag(e, element, card) {\n            draggedCard = { element, card };\n            element.classList.add('dragging');\n            \n            const rect = element.getBoundingClientRect();\n            dragOffset = {\n                x: (e.clientX - rect.left) / zoomLevel,\n                y: (e.clientY - rect.top) / zoomLevel\n            };\n\n            document.addEventListener('mousemove', onCardDrag);\n            document.addEventListener('mouseup', stopCardDrag);\n        }\n\n        function onCardDrag(e) {\n            if (!draggedCard) return;\n            e.preventDefault();\n\n            const pos = screenToWhiteboard(e.clientX, e.clientY);\n            const x = pos.x - dragOffset.x;\n            const y = pos.y - dragOffset.y;\n\n            draggedCard.element.style.left = x + 'px';\n            draggedCard.element.style.top = y + 'px';\n\n            draggedCard.card.x = x;\n            draggedCard.card.y = y;\n        }\n\n        function stopCardDrag() {\n            if (draggedCard) {\n                draggedCard.element.classList.remove('dragging');\n                draggedCard = null;\n                saveState();\n            }\n            document.removeEventListener('mousemove', onCardDrag);\n            document.removeEventListener('mouseup', stopCardDrag);\n        }\n\n        function startCardResize(e, element, card) {\n            resizingCard = { element, card, startX: e.clientX, startY: e.clientY, startW: element.offsetWidth, startH: element.offsetHeight };\n            document.addEventListener('mousemove', onCardResize);\n            document.addEventListener('mouseup', stopCardResize);\n        }\n\n        function onCardResize(e) {\n            if (!resizingCard) return;\n            e.preventDefault();\n            \n            const dx = (e.clientX - resizingCard.startX) / zoomLevel;\n            const dy = (e.clientY - resizingCard.startY) / zoomLevel;\n            \n            const newW = Math.max(250, resizingCard.startW + dx);\n            const newH = Math.max(150, resizingCard.startH + dy);\n            \n            resizingCard.element.style.width = newW + 'px';\n            resizingCard.element.style.height = newH + 'px';\n            resizingCard.card.width = newW;\n            resizingCard.card.height = newH;\n        }\n\n        function stopCardResize() {\n            if (resizingCard) {\n                resizingCard = null;\n                saveState();\n            }\n            document.removeEventListener('mousemove', onCardResize);\n            document.removeEventListener('mouseup', stopCardResize);\n        }\n\n        function addCard(filePath, x, y) {\n            const card = {\n                id: 'card_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),\n                x: x,\n                y: y,\n                width: 300,\n                height: 200,\n                filePath: filePath\n            };\n            cards.push(card);\n            const element = createCardElement(card);\n            whiteboard.appendChild(element);\n            vscode.postMessage({ command: 'readCardContent', cardId: card.id, filePath: card.filePath });\n            saveState();\n        }\n\n        function showCardContextMenu(e, cardId) {\n            contextCardId = cardId;\n            // Show color section for cards too\n            const colorSection = contextMenu.querySelector('.context-menu-section');\n            colorSection.style.display = 'block';\n            // Hide link/unlink options (cards are already linked to files)\n            document.getElementById('linkFileMenu').parentElement.style.display = 'none';\n            // Show card-specific actions (Rename, Move)\n            document.getElementById('cardActionsSection').style.display = 'block';\n            \n            let x = e.pageX;\n            let y = e.pageY;\n            if (x + 220 > window.innerWidth) x -= 220;\n            if (y + 280 > window.innerHeight) y -= 280;\n            \n            contextMenu.style.left = x + 'px';\n            contextMenu.style.top = y + 'px';\n            contextMenu.classList.add('active');\n        }\n\n        function showCanvasContextMenu(e) {\n            const pos = screenToWhiteboard(e.clientX, e.clientY);\n            pendingCardPosition = { x: pos.x, y: pos.y };\n            \n            let x = e.pageX;\n            let y = e.pageY;\n            if (x + 180 > window.innerWidth) x -= 180;\n            if (y + 100 > window.innerHeight) y -= 100;\n            \n            canvasContextMenu.style.left = x + 'px';\n            canvasContextMenu.style.top = y + 'px';\n            canvasContextMenu.classList.add('active');\n        }\n\n        function hideCanvasContextMenu() {\n            canvasContextMenu.classList.remove('active');\n        }\n\n        function openNewCardModal() {\n            newCardModal.classList.add('active');\n            document.getElementById('newCardFileName').value = '';\n            document.getElementById('newCardFileName').focus();\n            hideCanvasContextMenu();\n        }\n\n        function closeNewCardModal() {\n            newCardModal.classList.remove('active');\n            newFileForBlockMode = false;\n        }\n\n        function createNewCard() {\n            const fileName = document.getElementById('newCardFileName').value.trim();\n            if (!fileName) return;\n            \n            if (newFileForBlockMode && selectedBlockId) {\n                // Creating new file for block linking\n                vscode.postMessage({ \n                    command: 'createNewCard', \n                    fileName: fileName,\n                    x: 0,\n                    y: 0,\n                    forBlockId: selectedBlockId\n                });\n            } else {\n                // Creating new card on canvas\n                vscode.postMessage({ \n                    command: 'createNewCard', \n                    fileName: fileName,\n                    x: pendingCardPosition.x - 150,\n                    y: pendingCardPosition.y - 100\n                });\n            }\n            closeNewCardModal();\n        }\n\n        // ========== Rename Card Functions ==========\n        function openRenameModal(cardId, filePath) {\n            renameTargetCardId = cardId;\n            renameTargetPath = filePath;\n            \n            // Pre-fill with current filename (without extension)\n            const currentName = filePath.split('/').pop().replace('.md', '');\n            const input = document.getElementById('renameCardInput');\n            input.value = currentName;\n            \n            renameCardModal.classList.add('active');\n            input.focus();\n            input.select();\n        }\n\n        function closeRenameModal() {\n            renameCardModal.classList.remove('active');\n            renameTargetCardId = null;\n            renameTargetPath = null;\n        }\n\n        function confirmRename() {\n            const newName = document.getElementById('renameCardInput').value.trim();\n            if (!newName || !renameTargetCardId || !renameTargetPath) return;\n            \n            vscode.postMessage({\n                command: 'renameCard',\n                cardId: renameTargetCardId,\n                oldPath: renameTargetPath,\n                newName: newName\n            });\n            \n            closeRenameModal();\n        }\n\n        // ========== Move Card Functions ==========\n        function openMoveModal(cardId, filePath) {\n            moveTargetCardId = cardId;\n            moveTargetPath = filePath;\n            selectedFolderIndex = -1; // Reset selection\n            flatFolderList = []; // Reset folder list\n            \n            // Request folder list from extension\n            vscode.postMessage({ command: 'getWorkspaceFolders' });\n            \n            moveCardModal.classList.add('active');\n            document.getElementById('folderSearchInput').value = '';\n            document.getElementById('folderSearchInput').focus();\n        }\n\n        function closeMoveModal() {\n            moveCardModal.classList.remove('active');\n            moveTargetCardId = null;\n            moveTargetPath = null;\n            allWorkspaceFolders = [];\n            filteredFolders = [];\n        }\n\n        // Build folder tree structure from flat folder paths\n        function buildFolderTree(folders) {\n            const tree = { name: '', path: '', children: {} };\n            \n            folders.forEach(folderPath => {\n                if (folderPath === '') {\n                    // Root folder - already in tree\n                    return;\n                }\n                \n                const parts = folderPath.split('/');\n                let current = tree;\n                let currentPath = '';\n                \n                parts.forEach((part, index) => {\n                    currentPath = currentPath ? currentPath + '/' + part : part;\n                    if (!current.children[part]) {\n                        current.children[part] = {\n                            name: part,\n                            path: currentPath,\n                            children: {}\n                        };\n                    }\n                    current = current.children[part];\n                });\n            });\n            \n            return tree;\n        }\n\n        // Track expanded folders state\n        const expandedFolders = new Set(['']); // Root is expanded by default\n\n        function renderFolderTree(node, container, isRoot = false) {\n            const hasChildren = Object.keys(node.children).length > 0;\n            const isExpanded = expandedFolders.has(node.path);\n            \n            const itemDiv = document.createElement('div');\n            itemDiv.className = 'folder-tree-item';\n            \n            const rowDiv = document.createElement('div');\n            rowDiv.className = 'folder-tree-row' + (isRoot ? ' root-folder' : '');\n            rowDiv.dataset.path = node.path;\n            \n            // Toggle arrow (for folders with children)\n            const toggleDiv = document.createElement('div');\n            toggleDiv.className = 'folder-toggle' + (isExpanded ? ' expanded' : '') + (!hasChildren ? ' hidden' : '');\n            toggleDiv.innerHTML = '<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><polyline points=\"9 18 15 12 9 6\"></polyline></svg>';\n            \n            if (hasChildren) {\n                toggleDiv.addEventListener('click', (e) => {\n                    e.stopPropagation();\n                    if (expandedFolders.has(node.path)) {\n                        expandedFolders.delete(node.path);\n                    } else {\n                        expandedFolders.add(node.path);\n                    }\n                    renderFolderList(filteredFolders);\n                });\n            }\n            \n            // Folder icon\n            const iconDiv = document.createElement('div');\n            iconDiv.className = 'folder-icon';\n            iconDiv.innerHTML = '<svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2\"></path></svg>';\n            \n            // Folder name\n            const nameSpan = document.createElement('span');\n            nameSpan.className = 'folder-name';\n            nameSpan.textContent = isRoot ? '/ (\u6839\u76EE\u9304)' : node.name;\n            \n            rowDiv.appendChild(toggleDiv);\n            rowDiv.appendChild(iconDiv);\n            rowDiv.appendChild(nameSpan);\n            \n            // Click to select folder\n            rowDiv.addEventListener('click', () => selectFolder(node.path));\n            \n            itemDiv.appendChild(rowDiv);\n            \n            // Render children if expanded\n            if (hasChildren) {\n                const childrenDiv = document.createElement('div');\n                childrenDiv.className = 'folder-children' + (isExpanded ? '' : ' collapsed');\n                \n                // Sort children alphabetically\n                const sortedChildren = Object.values(node.children).sort((a, b) => a.name.localeCompare(b.name));\n                sortedChildren.forEach(child => {\n                    renderFolderTree(child, childrenDiv, false);\n                });\n                \n                itemDiv.appendChild(childrenDiv);\n            }\n            \n            container.appendChild(itemDiv);\n        }\n\n        // Collect visible folders in tree order for keyboard navigation\n        function collectVisibleFolders(node, result = []) {\n            result.push(node.path);\n            \n            if (expandedFolders.has(node.path)) {\n                const sortedChildren = Object.values(node.children).sort((a, b) => a.name.localeCompare(b.name));\n                sortedChildren.forEach(child => {\n                    collectVisibleFolders(child, result);\n                });\n            }\n            \n            return result;\n        }\n\n        function renderFolderList(folders) {\n            folderList.innerHTML = '';\n            \n            // Check if we're filtering (searching)\n            const searchQuery = document.getElementById('folderSearchInput').value.trim().toLowerCase();\n            \n            if (searchQuery) {\n                // Flat list for search results\n                flatFolderList = folders.slice(); // Copy the filtered folders\n                folders.forEach((folder, index) => {\n                    const item = document.createElement('div');\n                    item.className = 'folder-tree-row' + (index === selectedFolderIndex ? ' selected' : '');\n                    item.dataset.index = index;\n                    item.innerHTML = `\n                        <div class=\"folder-toggle hidden\"><svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><polyline points=\"9 18 15 12 9 6\"></polyline></svg></div>\n                        <div class=\"folder-icon\"><svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2\"></path></svg></div>\n                        <span class=\"folder-name\">${folder === '' ? '/ (\u6839\u76EE\u9304)' : folder}</span>\n                    `;\n                    item.addEventListener('click', () => selectFolder(folder));\n                    folderList.appendChild(item);\n                });\n            } else {\n                // Build and render tree structure\n                const tree = buildFolderTree(folders);\n                const treeContainer = document.createElement('div');\n                treeContainer.className = 'folder-tree';\n                \n                // Collect visible folders for keyboard navigation\n                flatFolderList = collectVisibleFolders(tree);\n                \n                // Render root folder first\n                renderFolderTree(tree, treeContainer, true);\n                \n                folderList.appendChild(treeContainer);\n            }\n            \n            // Update selected state\n            updateSelectedFolder();\n        }\n\n        function updateSelectedFolder() {\n            // Remove all selected states first\n            folderList.querySelectorAll('.folder-tree-row').forEach((row, i) => {\n                row.classList.remove('selected');\n            });\n            \n            // Add selected state to the correct item\n            if (selectedFolderIndex >= 0 && selectedFolderIndex < flatFolderList.length) {\n                const selectedPath = flatFolderList[selectedFolderIndex];\n                const selectedRow = folderList.querySelector(`.folder-tree-row[data-path=\"${selectedPath}\"]`);\n                if (selectedRow) {\n                    selectedRow.classList.add('selected');\n                    selectedRow.scrollIntoView({ block: 'nearest' });\n                } else {\n                    // For search results mode, use index\n                    const searchRows = folderList.querySelectorAll('.folder-tree-row');\n                    if (searchRows[selectedFolderIndex]) {\n                        searchRows[selectedFolderIndex].classList.add('selected');\n                        searchRows[selectedFolderIndex].scrollIntoView({ block: 'nearest' });\n                    }\n                }\n            }\n        }\n\n        function filterFolders(query) {\n            const lowerQuery = query.toLowerCase();\n            filteredFolders = allWorkspaceFolders.filter(f => \n                f.toLowerCase().includes(lowerQuery) || (f === '' && '\u6839\u76EE\u9304'.includes(lowerQuery))\n            );\n            selectedFolderIndex = -1; // Reset selection when filtering\n            renderFolderList(filteredFolders);\n        }\n\n        function selectFolder(folder) {\n            if (!moveTargetCardId || !moveTargetPath) return;\n            \n            vscode.postMessage({\n                command: 'moveCard',\n                cardId: moveTargetCardId,\n                oldPath: moveTargetPath,\n                targetFolder: folder\n            });\n            \n            closeMoveModal();\n        }\n\n        // Message handling\n        window.addEventListener('message', (event) => {\n            const message = event.data;\n            switch (message.command) {\n                case 'loadState':\n                    loadState(message.state);\n                    break;\n                case 'workspaceFiles':\n                    allWorkspaceFiles = message.files;\n                    renderFileList(message.files);\n                    break;\n                case 'fileSelected':\n                    if (message.blockId) {\n                        const block = blocks.find(b => b.id === message.blockId);\n                        if (block) {\n                            block.linkedFile = message.filePath;\n                            const element = document.getElementById(message.blockId);\n                            element.classList.add('linked');\n                            saveState();\n                        }\n                    }\n                    closeFileSelector();\n                    break;\n                case 'fileChanged':\n                    // File was changed externally (e.g., in VS Code editor)\n                    // Update the card content if it's not currently being edited\n                    const changedTextarea = document.querySelector(`textarea[data-card-id=\"${message.cardId}\"]`);\n                    if (changedTextarea) {\n                        // If card was disconnected, reconnect it\n                        const changedCard = changedTextarea.closest('.card');\n                        if (changedCard && changedCard.classList.contains('disconnected')) {\n                            changedCard.classList.remove('disconnected');\n                            const disconnectedContainer = changedCard.querySelector('.disconnected-container');\n                            if (disconnectedContainer) disconnectedContainer.style.display = 'none';\n                            changedTextarea.style.display = '';\n                        }\n                        \n                        // Only update if the textarea is not focused (user not actively editing)\n                        if (document.activeElement !== changedTextarea) {\n                            changedTextarea.value = message.content;\n                        } else {\n                            // If user is editing, store the new content and notify later\n                            changedTextarea.dataset.pendingContent = message.content;\n                            // Add a visual indicator that file was changed externally\n                            const card = changedTextarea.closest('.card');\n                            if (card && !card.classList.contains('external-change')) {\n                                card.classList.add('external-change');\n                                // Remove the indicator when user clicks away\n                                changedTextarea.addEventListener('blur', function onBlur() {\n                                    card.classList.remove('external-change');\n                                    changedTextarea.removeEventListener('blur', onBlur);\n                                }, { once: true });\n                            }\n                        }\n                    }\n                    break;\n                case 'fileDeleted':\n                    // File was deleted - show disconnected state\n                    const deletedCardTextarea = document.querySelector(`textarea[data-card-id=\"${message.cardId}\"]`);\n                    if (deletedCardTextarea) {\n                        const deletedCard = deletedCardTextarea.closest('.card');\n                        if (deletedCard && !deletedCard.classList.contains('disconnected')) {\n                            deletedCard.classList.add('disconnected');\n                            // Show disconnected message, hide textarea\n                            deletedCardTextarea.style.display = 'none';\n                            const disconnectedContainer = deletedCard.querySelector('.disconnected-container');\n                            if (disconnectedContainer) disconnectedContainer.style.display = 'flex';\n                        }\n                    }\n                    break;\n                case 'cardContent':\n                    const cardTextarea = document.querySelector(`textarea[data-card-id=\"${message.cardId}\"]`);\n                    if (cardTextarea) {\n                        // File exists - remove disconnected state if present\n                        const cardEl = cardTextarea.closest('.card');\n                        if (cardEl && cardEl.classList.contains('disconnected')) {\n                            cardEl.classList.remove('disconnected');\n                            const disconnectedContainer = cardEl.querySelector('.disconnected-container');\n                            if (disconnectedContainer) disconnectedContainer.style.display = 'none';\n                            cardTextarea.style.display = '';\n                        }\n                        cardTextarea.value = message.content;\n                        cardTextarea.placeholder = 'Type here...';\n                    }\n                    break;\n                case 'cardCreated':\n                    if (message.forBlockId) {\n                        // Link to block instead of creating card\n                        const block = blocks.find(b => b.id === message.forBlockId);\n                        if (block) {\n                            block.linkedFile = message.filePath;\n                            const element = document.getElementById(message.forBlockId);\n                            if (element) element.classList.add('linked');\n                            saveState();\n                        }\n                    } else {\n                        addCard(message.filePath, message.x, message.y);\n                    }\n                    break;\n                case 'fileRenamed':\n                    // Card's linked file was renamed - update the card\n                    const renamedCard = cards.find(c => c.id === message.cardId);\n                    if (renamedCard) {\n                        renamedCard.filePath = message.newPath;\n                        // Update the filename display in the header\n                        const cardElement = document.getElementById(message.cardId);\n                        if (cardElement) {\n                            const filenameSpan = cardElement.querySelector('.filename');\n                            if (filenameSpan) {\n                                filenameSpan.textContent = getFileName(message.newPath);\n                            }\n                        }\n                        saveState();\n                    }\n                    break;\n                case 'blockFileRenamed':\n                    // Block's linked file was renamed - update the block\n                    const renamedBlock = blocks.find(b => b.id === message.blockId);\n                    if (renamedBlock) {\n                        renamedBlock.linkedFile = message.newPath;\n                        saveState();\n                    }\n                    break;\n                case 'cardRenamed':\n                    // Card was renamed via context menu\n                    const cardToRename = cards.find(c => c.id === message.cardId);\n                    if (cardToRename) {\n                        cardToRename.filePath = message.newPath;\n                        // Update the filename display in the header\n                        const cardEl = document.getElementById(message.cardId);\n                        if (cardEl) {\n                            const filenameSpan = cardEl.querySelector('.filename');\n                            if (filenameSpan) {\n                                filenameSpan.textContent = getFileName(message.newPath);\n                            }\n                        }\n                        saveState();\n                    }\n                    break;\n                case 'cardMoved':\n                    // Card was moved to another folder via context menu\n                    const cardToMove = cards.find(c => c.id === message.cardId);\n                    if (cardToMove) {\n                        cardToMove.filePath = message.newPath;\n                        // Update the filename display (path may have changed)\n                        const movedCardEl = document.getElementById(message.cardId);\n                        if (movedCardEl) {\n                            const filenameSpan = movedCardEl.querySelector('.filename');\n                            if (filenameSpan) {\n                                filenameSpan.textContent = getFileName(message.newPath);\n                            }\n                        }\n                        saveState();\n                    }\n                    break;\n                case 'workspaceFolders':\n                    // Received folder list for move modal\n                    allWorkspaceFolders = message.folders;\n                    filteredFolders = message.folders;\n                    renderFolderList(message.folders);\n                    break;\n                case 'pinnedFileContent':\n                    // Received content for pinned file in sidebar\n                    const pinnedTextarea = document.getElementById('pinnedTextarea');\n                    if (pinnedTextarea && message.filePath === currentPinnedFile) {\n                        pinnedTextarea.value = message.content;\n                    }\n                    break;\n            }\n        });\n\n        // Event listeners\n        document.getElementById('addBlock').addEventListener('click', () => addBlock());\n        document.getElementById('saveBtn').addEventListener('click', forceSave);\n        document.getElementById('deleteBlockMenu').addEventListener('click', () => {\n            if (contextCardId) {\n                // Delete card\n                cards = cards.filter(c => c.id !== contextCardId);\n                const el = document.getElementById(contextCardId);\n                if (el) el.remove();\n                contextCardId = null;\n                forceSave(); // Use forceSave for delete operations\n                hideContextMenu();\n            } else {\n                deleteBlock();\n            }\n        });\n        document.getElementById('linkFileMenu').addEventListener('click', () => openFileSelector());\n        document.getElementById('unlinkFileMenu').addEventListener('click', unlinkFile);\n\n        // Card-specific context menu actions\n        document.getElementById('renameCardMenu').addEventListener('click', () => {\n            if (!contextCardId) return;\n            const card = cards.find(c => c.id === contextCardId);\n            if (card) {\n                openRenameModal(card.id, card.filePath);\n            }\n            hideContextMenu();\n        });\n\n        document.getElementById('moveCardMenu').addEventListener('click', () => {\n            if (!contextCardId) return;\n            const card = cards.find(c => c.id === contextCardId);\n            if (card) {\n                openMoveModal(card.id, card.filePath);\n            }\n            hideContextMenu();\n        });\n\n        // Canvas context menu\n        document.getElementById('addBlockFromMenu').addEventListener('click', () => {\n            addBlock(pendingCardPosition.x - 100, pendingCardPosition.y - 50);\n            hideCanvasContextMenu();\n        });\n        document.getElementById('addCardFromMenu').addEventListener('click', () => openFileSelector(null, 'card'));\n\n        // New card modal\n        document.getElementById('createCardBtn').addEventListener('click', createNewCard);\n        document.getElementById('closeNewCardModal').addEventListener('click', closeNewCardModal);\n        document.getElementById('newCardFileName').addEventListener('keydown', (e) => {\n            if (e.key === 'Enter') createNewCard();\n            if (e.key === 'Escape') closeNewCardModal();\n        });\n\n        // Click outside modal to close (on the overlay background)\n        document.getElementById('fileModal').addEventListener('click', (e) => {\n            if (e.target.id === 'fileModal') {\n                closeFileSelector();\n            }\n        });\n        document.getElementById('newCardModal').addEventListener('click', (e) => {\n            if (e.target.id === 'newCardModal') {\n                closeNewCardModal();\n            }\n        });\n\n        // Rename card modal\n        document.getElementById('confirmRenameBtn').addEventListener('click', confirmRename);\n        document.getElementById('closeRenameModal').addEventListener('click', closeRenameModal);\n        document.getElementById('renameCardInput').addEventListener('keydown', (e) => {\n            if (e.key === 'Enter') confirmRename();\n            if (e.key === 'Escape') closeRenameModal();\n        });\n        document.getElementById('renameCardModal').addEventListener('click', (e) => {\n            if (e.target.id === 'renameCardModal') {\n                closeRenameModal();\n            }\n        });\n\n        // Move card modal\n        document.getElementById('folderSearchInput').addEventListener('input', (e) => {\n            filterFolders(e.target.value);\n        });\n        document.getElementById('folderSearchInput').addEventListener('keydown', (e) => {\n            const totalItems = flatFolderList.length;\n            \n            if (e.key === 'ArrowDown') {\n                e.preventDefault();\n                if (selectedFolderIndex >= totalItems - 1) {\n                    // At the end, wrap to input (-1)\n                    selectedFolderIndex = -1;\n                } else {\n                    selectedFolderIndex = selectedFolderIndex + 1;\n                }\n                updateSelectedFolder();\n            } else if (e.key === 'ArrowUp') {\n                e.preventDefault();\n                if (selectedFolderIndex <= -1) {\n                    // At input, jump to last item (bottom)\n                    selectedFolderIndex = totalItems - 1;\n                } else {\n                    selectedFolderIndex = selectedFolderIndex - 1;\n                }\n                updateSelectedFolder();\n            } else if (e.key === 'Enter') {\n                e.preventDefault();\n                if (selectedFolderIndex >= 0 && selectedFolderIndex < totalItems) {\n                    selectFolder(flatFolderList[selectedFolderIndex]);\n                }\n            } else if (e.key === 'Escape') {\n                closeMoveModal();\n            }\n        });\n        document.getElementById('moveCardModal').addEventListener('click', (e) => {\n            if (e.target.id === 'moveCardModal') {\n                closeMoveModal();\n            }\n        });\n\n        // Escape key to close modals\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Escape') {\n                if (fileModal.classList.contains('active')) {\n                    closeFileSelector();\n                }\n                if (newCardModal.classList.contains('active')) {\n                    closeNewCardModal();\n                }\n                if (renameCardModal.classList.contains('active')) {\n                    closeRenameModal();\n                }\n                if (moveCardModal.classList.contains('active')) {\n                    closeMoveModal();\n                }\n            }\n        });\n\n        // Zoom controls - use viewport center and smooth animation\n        document.getElementById('zoomIn').addEventListener('click', () => {\n            setZoom(zoomLevel + 0.1, null, null, true);\n        });\n        document.getElementById('zoomOut').addEventListener('click', () => {\n            setZoom(zoomLevel - 0.1, null, null, true);\n        });\n        document.getElementById('resetZoom').addEventListener('click', () => {\n            // Smooth transition for reset\n            whiteboard.style.transition = 'transform 0.3s ease-out';\n            setZoom(1, null, null, false);\n            centerWhiteboard();\n            setTimeout(() => {\n                whiteboard.style.transition = '';\n            }, 300);\n        });\n\n        // Canvas panning with middle mouse button or Alt+drag\n        let isPanning = false;\n        let panStart = { x: 0, y: 0 };\n\n        canvasContainer.addEventListener('mousedown', (e) => {\n            // Middle mouse button (button 1) or Alt+left click for panning\n            if (e.button === 1 || (e.button === 0 && e.altKey)) {\n                isPanning = true;\n                panStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };\n                canvasContainer.style.cursor = 'grabbing';\n                e.preventDefault();\n                return;\n            }\n            \n            // Left click on empty canvas area - start selection box\n            if (e.button === 0 && (e.target === whiteboard || e.target === canvasContainer)) {\n                // Exit all editing modes when clicking empty area\n                exitAllEditingModes();\n                \n                // Clear selection if not holding Shift\n                if (!e.shiftKey) {\n                    clearSelection();\n                }\n                startSelectionBox(e);\n                e.preventDefault();\n            }\n        });\n\n        document.addEventListener('mousemove', (e) => {\n            if (isPanning) {\n                panOffset.x = e.clientX - panStart.x;\n                panOffset.y = e.clientY - panStart.y;\n                updateWhiteboardTransform();\n            }\n            \n            // Update selection box if selecting\n            if (isSelecting) {\n                updateSelectionBox(e);\n            }\n        });\n\n        document.addEventListener('mouseup', (e) => {\n            if (isPanning) {\n                isPanning = false;\n                canvasContainer.style.cursor = 'grab';\n            }\n            \n            // End selection box if selecting\n            if (isSelecting) {\n                endSelectionBox(e, e.shiftKey);\n            }\n        });\n\n        // Also support Space+drag for panning (like in design tools)\n        let spacePressed = false;\n        document.addEventListener('keydown', (e) => {\n            // Skip all keyboard shortcuts if editing text\n            if (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'INPUT') {\n                // Only handle Space for panning if not in text input\n                return;\n            }\n            \n            if (e.code === 'Space' && !e.repeat) {\n                spacePressed = true;\n                canvasContainer.style.cursor = 'grab';\n            }\n            \n            // Delete/Backspace to delete selected items\n            if (e.code === 'Delete' || e.code === 'Backspace') {\n                deleteSelectedItems();\n                e.preventDefault();\n            }\n        });\n\n        /**\n         * Delete all selected blocks and cards\n         */\n        function deleteSelectedItems() {\n            if (selectedBlocks.size === 0 && selectedCards.size === 0) return;\n            \n            // Delete selected blocks\n            selectedBlocks.forEach(blockId => {\n                blocks = blocks.filter(b => b.id !== blockId);\n                const element = document.getElementById(blockId);\n                if (element) {\n                    element.style.transform = 'scale(0)';\n                    element.style.opacity = '0';\n                    setTimeout(() => element.remove(), 200);\n                }\n            });\n            \n            // Delete selected cards\n            selectedCards.forEach(cardId => {\n                cards = cards.filter(c => c.id !== cardId);\n                const element = document.getElementById(cardId);\n                if (element) {\n                    element.style.transform = 'scale(0)';\n                    element.style.opacity = '0';\n                    setTimeout(() => element.remove(), 200);\n                }\n            });\n            \n            // Clear selection\n            selectedBlocks.clear();\n            selectedCards.clear();\n            \n            // Force save immediately for delete operations\n            forceSave();\n        }\n\n        document.addEventListener('keyup', (e) => {\n            if (e.code === 'Space') {\n                spacePressed = false;\n                if (!isPanning) {\n                    canvasContainer.style.cursor = 'grab';\n                }\n            }\n        });\n\n        canvasContainer.addEventListener('mousedown', (e) => {\n            if (spacePressed && e.button === 0) {\n                isPanning = true;\n                panStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };\n                canvasContainer.style.cursor = 'grabbing';\n                e.preventDefault();\n            }\n        });\n\n        // Double-click to add block\n        canvasContainer.addEventListener('dblclick', (e) => {\n            if (e.target === whiteboard || e.target === canvasContainer) {\n                const pos = screenToWhiteboard(e.clientX, e.clientY);\n                addBlock(pos.x - 100, pos.y - 50);\n            }\n        });\n\n        // Hide context menus on click outside\n        document.addEventListener('click', (e) => {\n            if (!contextMenu.contains(e.target)) {\n                hideContextMenu();\n                // Reset visibility of sections for block context menu\n                const colorSection = contextMenu.querySelector('.context-menu-section');\n                if (colorSection) colorSection.style.display = '';\n                const linkSection = document.getElementById('linkFileMenu');\n                if (linkSection && linkSection.parentElement) linkSection.parentElement.style.display = '';\n                // Hide card-specific actions\n                const cardActionsSection = document.getElementById('cardActionsSection');\n                if (cardActionsSection) cardActionsSection.style.display = 'none';\n                contextCardId = null;\n            }\n            if (!canvasContextMenu.contains(e.target)) {\n                hideCanvasContextMenu();\n            }\n        });\n\n        // Canvas right-click context menu\n        canvasContainer.addEventListener('contextmenu', (e) => {\n            if (e.target === whiteboard || e.target === canvasContainer) {\n                e.preventDefault();\n                showCanvasContextMenu(e);\n            }\n        });\n\n        // Drag and drop .md files from explorer\n        canvasContainer.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            e.dataTransfer.dropEffect = 'copy';\n            dropIndicator.classList.add('active');\n        });\n\n        canvasContainer.addEventListener('dragleave', (e) => {\n            if (!canvasContainer.contains(e.relatedTarget)) {\n                dropIndicator.classList.remove('active');\n            }\n        });\n\n        canvasContainer.addEventListener('drop', (e) => {\n            e.preventDefault();\n            dropIndicator.classList.remove('active');\n            \n            // VS Code drag-drop provides file path in dataTransfer\n            const files = e.dataTransfer.files;\n            const uriList = e.dataTransfer.getData('text/uri-list');\n            \n            // Calculate drop position\n            const pos = screenToWhiteboard(e.clientX, e.clientY);\n            const x = pos.x - 150;\n            const y = pos.y - 100;\n            \n            // Try to get relative path from VS Code\n            if (uriList) {\n                const uri = uriList.split('\\n')[0].trim();\n                if (uri.endsWith('.md')) {\n                    // Extract relative path - this may need adjustment based on VS Code's format\n                    let filePath = decodeURIComponent(uri.replace('file://', ''));\n                    // Try to make it relative if workspace info is available\n                    addCard(filePath, x, y);\n                }\n            }\n        });\n\n        // Smooth Mouse wheel zoom and trackpad pan\n        canvasContainer.addEventListener('wheel', (e) => {\n            // If the active element is a textarea (editing card), let it scroll naturally\n            const activeElement = document.activeElement;\n            if (activeElement && activeElement.tagName === 'TEXTAREA') {\n                const textarea = activeElement;\n                // Check if the textarea can scroll (has overflow)\n                const canScrollUp = textarea.scrollTop > 0;\n                const canScrollDown = textarea.scrollTop < (textarea.scrollHeight - textarea.clientHeight);\n                \n                // If scrolling down and can scroll down, or scrolling up and can scroll up\n                // Let the native scroll happen\n                if ((e.deltaY > 0 && canScrollDown) || (e.deltaY < 0 && canScrollUp)) {\n                    // Don't prevent default - allow textarea to scroll\n                    e.stopPropagation();\n                    return;\n                }\n                \n                // If inside an editing card, check if mouse is over the card\n                // If so, don't pan the whiteboard - this prevents accidental panning while editing\n                const editingCard = textarea.closest('.card.editing');\n                if (editingCard) {\n                    const cardRect = editingCard.getBoundingClientRect();\n                    if (e.clientX >= cardRect.left && e.clientX <= cardRect.right &&\n                        e.clientY >= cardRect.top && e.clientY <= cardRect.bottom) {\n                        // Mouse is inside editing card - don't pan unless using Ctrl/Cmd for zoom\n                        if (!e.ctrlKey && !e.metaKey) {\n                            e.preventDefault();\n                            return;\n                        }\n                    }\n                }\n            }\n            \n            e.preventDefault();\n            \n            if (e.ctrlKey || e.metaKey) {\n                // Pinch zoom (ctrl+wheel or trackpad pinch)\n                // Smooth zoom calculation centered on mouse position\n                const zoomSensitivity = 0.0015;\n                const delta = -e.deltaY * zoomSensitivity;\n                const newZoom = zoomLevel + delta;\n                \n                // Zoom centered on mouse position\n                setZoom(newZoom, e.clientX, e.clientY);\n            } else {\n                // Trackpad two-finger pan or regular scroll\n                panOffset.x -= e.deltaX;\n                panOffset.y -= e.deltaY;\n                updateWhiteboardTransform();\n            }\n        }, { passive: false });\n\n        // Load initial state\n        vscode.postMessage({ command: 'requestState' });\n\n        // ========== Sidebar Functions ==========\n        \n        /**\n         * Initialize sidebar with loaded state data\n         */\n        function initSidebar() {\n            // Initialize color filter options\n            initColorFilter();\n            \n            // Render pinned files\n            renderPinnedFiles();\n            \n            // Render card list\n            renderCardList();\n            \n            // Render stash\n            renderStash();\n        }\n        \n        /**\n         * Toggle sidebar open/close (overlay mode - doesn't push canvas)\n         */\n        function toggleSidebar() {\n            sidebarOpen = !sidebarOpen;\n            if (sidebarOpen) {\n                sidebar.classList.add('open');\n            } else {\n                sidebar.classList.remove('open');\n            }\n        }\n        \n        /**\n         * Switch sidebar tab\n         */\n        function switchTab(tabName) {\n            // Update tab buttons\n            [tabPinned, tabCards, tabStash].forEach(tab => tab.classList.remove('active'));\n            [panelPinned, panelCards, panelStash].forEach(panel => panel.classList.remove('active'));\n            \n            if (tabName === 'pinned') {\n                tabPinned.classList.add('active');\n                panelPinned.classList.add('active');\n            } else if (tabName === 'cards') {\n                tabCards.classList.add('active');\n                panelCards.classList.add('active');\n                renderCardList(); // Refresh list when switching to this tab\n            } else if (tabName === 'stash') {\n                tabStash.classList.add('active');\n                panelStash.classList.add('active');\n                renderStash();\n            }\n        }\n        \n        // Sidebar event listeners\n        toggleSidebarBtn.addEventListener('click', toggleSidebar);\n        closeSidebarBtn.addEventListener('click', toggleSidebar);\n        tabPinned.addEventListener('click', () => switchTab('pinned'));\n        tabCards.addEventListener('click', () => switchTab('cards'));\n        tabStash.addEventListener('click', () => switchTab('stash'));\n        \n        // ========== Tab 1: Pinned Files ==========\n        \n        function renderPinnedFiles() {\n            if (pinnedFiles.length === 0) {\n                pinnedEmpty.style.display = 'flex';\n                pinnedFileViewer.style.display = 'none';\n                pinnedFileViewer.innerHTML = '';\n                currentPinnedFile = null;\n                return;\n            }\n            \n            pinnedEmpty.style.display = 'none';\n            pinnedFileViewer.style.display = 'block';\n            \n            // For now, show the first pinned file\n            if (!currentPinnedFile || !pinnedFiles.includes(currentPinnedFile)) {\n                currentPinnedFile = pinnedFiles[0];\n            }\n            \n            pinnedFileViewer.innerHTML = `\n                <div class=\"pinned-file-viewer\">\n                    <div class=\"pinned-file-header\">\n                        <svg class=\"icon-sm\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                            <path d=\"M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z\"></path>\n                            <polyline points=\"14 2 14 8 20 8\"></polyline>\n                        </svg>\n                        <span class=\"filename\">${getFileName(currentPinnedFile)}</span>\n                        <div class=\"pinned-file-actions\">\n                            <button class=\"open-pinned\" title=\"Open in Editor\">\n                                <svg class=\"icon-sm\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                                    <path d=\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"></path>\n                                    <polyline points=\"15 3 21 3 21 9\"></polyline>\n                                    <line x1=\"10\" y1=\"14\" x2=\"21\" y2=\"3\"></line>\n                                </svg>\n                            </button>\n                            <button class=\"unpin-file\" title=\"Unpin\">\n                                <svg class=\"icon-sm\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                                    <line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\"></line>\n                                    <line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\"></line>\n                                </svg>\n                            </button>\n                        </div>\n                    </div>\n                    <div class=\"pinned-file-content\">\n                        <textarea class=\"pinned-file-textarea\" id=\"pinnedTextarea\" placeholder=\"Loading...\"></textarea>\n                    </div>\n                </div>\n            `;\n            \n            // Add event listeners\n            pinnedFileViewer.querySelector('.open-pinned').addEventListener('click', () => {\n                vscode.postMessage({ command: 'openFile', filePath: currentPinnedFile, splitView: true });\n            });\n            \n            pinnedFileViewer.querySelector('.unpin-file').addEventListener('click', () => {\n                pinnedFiles = pinnedFiles.filter(f => f !== currentPinnedFile);\n                currentPinnedFile = null;\n                renderPinnedFiles();\n                saveState();\n            });\n            \n            // Load file content\n            vscode.postMessage({ command: 'readPinnedFileContent', filePath: currentPinnedFile });\n            \n            // Save on change with debounce\n            const textarea = pinnedFileViewer.querySelector('#pinnedTextarea');\n            let pinnedSaveTimeout;\n            textarea.addEventListener('input', () => {\n                clearTimeout(pinnedSaveTimeout);\n                pinnedSaveTimeout = setTimeout(() => {\n                    vscode.postMessage({ \n                        command: 'savePinnedFileContent', \n                        filePath: currentPinnedFile, \n                        content: textarea.value \n                    });\n                }, 500);\n            });\n        }\n        \n        selectPinnedFileBtn.addEventListener('click', () => {\n            openFileSelector(null, 'pinned');\n        });\n        \n        // ========== Tab 2: Card List ==========\n        \n        function initColorFilter() {\n            // Clear existing options except the first \"All colors\" option\n            colorFilterSelect.innerHTML = '<option value=\"\">\u6240\u6709\u984F\u8272</option>';\n            \n            // Add color options\n            const colorNames = {\n                '#2563eb': '\u85CD\u8272',\n                '#dc2626': '\u7D05\u8272',\n                '#ea580c': '\u6A58\u8272',\n                '#16a34a': '\u7DA0\u8272',\n                '#4b5563': '\u6DF1\u7070',\n                '#7c3aed': '\u7D2B\u8272',\n                '#db2777': '\u7C89\u8272',\n                '#92400e': '\u5496\u5561'\n            };\n            \n            colors.forEach(color => {\n                const option = document.createElement('option');\n                option.value = color;\n                option.textContent = colorNames[color] || color;\n                option.style.color = color;\n                colorFilterSelect.appendChild(option);\n            });\n        }\n        \n        colorFilterSelect.addEventListener('change', (e) => {\n            currentColorFilter = e.target.value;\n            renderCardList();\n        });\n        \n        function formatTimeAgo(timestamp) {\n            if (!timestamp) return '';\n            const now = Date.now();\n            const diff = now - timestamp;\n            \n            const minutes = Math.floor(diff / (1000 * 60));\n            const hours = Math.floor(diff / (1000 * 60 * 60));\n            const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n            \n            if (minutes < 1) return '\u525B\u525B';\n            if (minutes < 60) return minutes + ' \u5206\u9418\u524D';\n            if (hours < 24) return hours + ' \u5C0F\u6642\u524D';\n            if (days < 30) return days + ' \u5929\u524D';\n            return new Date(timestamp).toLocaleDateString();\n        }\n        \n        function renderCardList() {\n            // Filter and sort cards\n            let filteredCards = [...cards];\n            \n            if (currentColorFilter) {\n                filteredCards = filteredCards.filter(c => c.color === currentColorFilter);\n            }\n            \n            // Sort by lastModified (newest first)\n            filteredCards.sort((a, b) => (b.lastModified || 0) - (a.lastModified || 0));\n            \n            if (filteredCards.length === 0) {\n                cardListElem.style.display = 'none';\n                cardListEmpty.style.display = 'block';\n                cardListEmpty.textContent = currentColorFilter ? '\u6C92\u6709\u7B26\u5408\u7BE9\u9078\u7684\u5361\u7247' : '\u767D\u677F\u4E2D\u6C92\u6709\u5361\u7247';\n                return;\n            }\n            \n            cardListElem.style.display = 'flex';\n            cardListEmpty.style.display = 'none';\n            \n            cardListElem.innerHTML = filteredCards.map(card => `\n                <div class=\"card-list-item\" data-card-id=\"${card.id}\" draggable=\"true\">\n                    <div class=\"color-dot\" style=\"background: ${card.color || '#4b5563'}\"></div>\n                    <div class=\"card-info\">\n                        <div class=\"card-name\">${getFileName(card.filePath)}</div>\n                        <div class=\"card-time\">${formatTimeAgo(card.lastModified)}</div>\n                    </div>\n                </div>\n            `).join('');\n            \n            // Add click listeners to navigate to card\n            cardListElem.querySelectorAll('.card-list-item').forEach(item => {\n                item.addEventListener('click', () => {\n                    const cardId = item.dataset.cardId;\n                    navigateToCard(cardId);\n                });\n                \n                // Add drag listener for stash\n                item.addEventListener('dragstart', (e) => {\n                    e.dataTransfer.setData('text/plain', item.dataset.cardId);\n                    e.dataTransfer.effectAllowed = 'move';\n                    cardBeingDraggedToStash = item.dataset.cardId;\n                });\n                \n                item.addEventListener('dragend', () => {\n                    cardBeingDraggedToStash = null;\n                });\n            });\n        }\n        \n        function navigateToCard(cardId) {\n            const card = cards.find(c => c.id === cardId);\n            if (!card) return;\n            \n            const cardEl = document.getElementById(cardId);\n            if (!cardEl) return;\n            \n            // Calculate the center position of the card\n            const cardCenterX = card.x + (card.width || 280) / 2;\n            const cardCenterY = card.y + (card.height || 200) / 2;\n            \n            // Calculate the viewport center\n            const viewportCenterX = canvasContainer.clientWidth / 2;\n            const viewportCenterY = canvasContainer.clientHeight / 2;\n            \n            // Calculate new pan offset to center the card\n            panOffset.x = viewportCenterX - cardCenterX * zoomLevel;\n            panOffset.y = viewportCenterY - cardCenterY * zoomLevel;\n            \n            // Smooth transition\n            whiteboard.style.transition = 'transform 0.3s ease-out';\n            updateWhiteboardTransform();\n            \n            setTimeout(() => {\n                whiteboard.style.transition = '';\n            }, 300);\n            \n            // Highlight the card briefly\n            cardEl.classList.add('selected');\n            clearSelection();\n            selectedCards.add(cardId);\n        }\n        \n        // ========== Tab 3: Stash ==========\n        \n        function renderStash() {\n            if (stashCards.length === 0) {\n                stashListElem.style.display = 'none';\n                stashEmpty.style.display = 'block';\n                return;\n            }\n            \n            stashListElem.style.display = 'flex';\n            stashEmpty.style.display = 'none';\n            \n            // Sort by lastModified (newest first)\n            const sortedStash = [...stashCards].sort((a, b) => (b.lastModified || 0) - (a.lastModified || 0));\n            \n            stashListElem.innerHTML = sortedStash.map(item => `\n                <div class=\"stash-item\" data-stash-id=\"${item.id}\">\n                    <div class=\"color-dot\" style=\"background: ${item.color || '#4b5563'}\"></div>\n                    <div class=\"stash-info\">\n                        <div class=\"stash-name\">${getFileName(item.filePath)}</div>\n                    </div>\n                    <div class=\"stash-item-actions\">\n                        <button class=\"restore\" title=\"\u6062\u5FA9\u5230\u767D\u677F\">\n                            <svg class=\"icon-sm\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                                <polyline points=\"1 4 1 10 7 10\"></polyline>\n                                <path d=\"M3.51 15a9 9 0 1 0 2.13-9.36L1 10\"></path>\n                            </svg>\n                        </button>\n                        <button class=\"delete\" title=\"\u6C38\u4E45\u522A\u9664\">\n                            <svg class=\"icon-sm\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                                <polyline points=\"3 6 5 6 21 6\"></polyline>\n                                <path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path>\n                            </svg>\n                        </button>\n                    </div>\n                </div>\n            `).join('');\n            \n            // Add event listeners\n            stashListElem.querySelectorAll('.stash-item').forEach(item => {\n                const stashId = item.dataset.stashId;\n                \n                item.querySelector('.restore').addEventListener('click', () => {\n                    restoreFromStash(stashId);\n                });\n                \n                item.querySelector('.delete').addEventListener('click', () => {\n                    deleteFromStash(stashId);\n                });\n            });\n        }\n        \n        function moveCardToStash(cardId) {\n            const card = cards.find(c => c.id === cardId);\n            if (!card) return;\n            \n            // Add to stash\n            stashCards.push({\n                id: card.id,\n                filePath: card.filePath,\n                color: card.color,\n                lastModified: Date.now()\n            });\n            \n            // Remove from whiteboard\n            cards = cards.filter(c => c.id !== cardId);\n            const cardEl = document.getElementById(cardId);\n            if (cardEl) {\n                cardEl.style.transform = 'scale(0)';\n                cardEl.style.opacity = '0';\n                setTimeout(() => cardEl.remove(), 200);\n            }\n            \n            renderStash();\n            renderCardList();\n            saveState();\n        }\n        \n        function restoreFromStash(stashId) {\n            const stashItem = stashCards.find(s => s.id === stashId);\n            if (!stashItem) return;\n            \n            // Get center of viewport for placement\n            const centerPos = screenToWhiteboard(canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2);\n            \n            // Create new card\n            const newCard = {\n                id: stashItem.id,\n                x: centerPos.x - 140,\n                y: centerPos.y - 100,\n                width: 280,\n                height: 200,\n                filePath: stashItem.filePath,\n                color: stashItem.color,\n                lastModified: Date.now()\n            };\n            \n            cards.push(newCard);\n            const element = createCardElement(newCard);\n            whiteboard.appendChild(element);\n            vscode.postMessage({ command: 'readCardContent', cardId: newCard.id, filePath: newCard.filePath });\n            \n            // Remove from stash\n            stashCards = stashCards.filter(s => s.id !== stashId);\n            \n            renderStash();\n            renderCardList();\n            saveState();\n        }\n        \n        function deleteFromStash(stashId) {\n            stashCards = stashCards.filter(s => s.id !== stashId);\n            renderStash();\n            saveState();\n        }\n        \n        // Stash dropzone events\n        stashDropzone.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            stashDropzone.classList.add('drag-over');\n        });\n        \n        stashDropzone.addEventListener('dragleave', (e) => {\n            stashDropzone.classList.remove('drag-over');\n        });\n        \n        stashDropzone.addEventListener('drop', (e) => {\n            e.preventDefault();\n            stashDropzone.classList.remove('drag-over');\n            \n            const cardId = e.dataTransfer.getData('text/plain');\n            if (cardId && cards.find(c => c.id === cardId)) {\n                moveCardToStash(cardId);\n                // Switch to stash tab\n                switchTab('stash');\n            }\n        });\n        \n        // Make cards on whiteboard draggable to stash\n        function enableCardDragToStash(cardElement, card) {\n            cardElement.setAttribute('draggable', 'true');\n            \n            cardElement.addEventListener('dragstart', (e) => {\n                // Only allow drag from header\n                if (!e.target.closest('.card-header')) {\n                    e.preventDefault();\n                    return;\n                }\n                e.dataTransfer.setData('text/plain', card.id);\n                e.dataTransfer.effectAllowed = 'move';\n                cardBeingDraggedToStash = card.id;\n                cardElement.style.opacity = '0.5';\n            });\n            \n            cardElement.addEventListener('dragend', () => {\n                cardBeingDraggedToStash = null;\n                cardElement.style.opacity = '1';\n            });\n        }\n        \n        // Update card's lastModified when content changes\n        function updateCardLastModified(cardId) {\n            const card = cards.find(c => c.id === cardId);\n            if (card) {\n                card.lastModified = Date.now();\n            }\n        }\n\n        // Center the whiteboard view on load\n        function centerWhiteboard() {\n            const whiteboardWidth = whiteboard.offsetWidth;\n            const whiteboardHeight = whiteboard.offsetHeight;\n            const containerWidth = canvasContainer.clientWidth;\n            const containerHeight = canvasContainer.clientHeight;\n            \n            // Calculate center position\n            const centerX = (whiteboardWidth - containerWidth) / 2;\n            const centerY = (whiteboardHeight - containerHeight) / 2;\n            \n            // Set pan offset to center\n            panOffset.x = -centerX;\n            panOffset.y = -centerY;\n            updateWhiteboardTransform();\n        }\n        \n        // Center on initial load\n        setTimeout(centerWhiteboard, 100);\n\n        // Icons are now inline SVGs, no initialization needed\n";
//# sourceMappingURL=scripts.d.ts.map